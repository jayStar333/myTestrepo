#Method 1

import pyodbc
import pandas as pd
import datetime

# Database connection parameters
server = 'your_server'
database = 'your_database'
username = 'your_username'
password = 'your_password'
connection_string = f'DRIVER={{ODBC Driver 17 for SQL Server}};SERVER={server};DATABASE={database};UID={username};PWD={password}'

# Connect to the database
conn = pyodbc.connect(connection_string)

# Read the list of tables from a CSV file
tables_df = pd.read_csv('tables_list.csv')
tables = tables_df['table_name'].tolist()

# Generate a range of dates dynamically for the last 7 days
end_date = datetime.date.today()
start_date = end_date - datetime.timedelta(days=6)
date_range = pd.date_range(start=start_date, end=end_date)

# Query each table and store results in a DataFrame
results = []
for table in tables:
    query = f"""
    SELECT 
        '{table}' AS table_name,
        CAST(date_column AS DATE) AS date,
        COUNT(*) AS row_count
    FROM {table}
    WHERE CAST(date_column AS DATE) BETWEEN '{start_date}' AND '{end_date}'
    GROUP BY CAST(date_column AS DATE)
    """
    df = pd.read_sql(query, conn)
    
    # Ensure all dates in the range are represented
    df = df.set_index('date').reindex(date_range, fill_value=0).reset_index()
    df['table_name'] = table
    results.append(df)

# Concatenate all results into a single DataFrame
final_df = pd.concat(results, ignore_index=True)

# Close the database connection
conn.close()

# Save the final DataFrame to a CSV file
final_df.to_csv('final_results.csv', index=False)

# Create a CSS-styled HTML table
html_output = final_df.to_html(classes='styled-table', index=False)

# Add CSS styling with a banner at the top
css = """
<style>
body {
    font-family: sans-serif;
}
.banner {
    text-align: center;
    font-size: 2em;
    margin-top: 20px;
}
.thin-bar {
    height: 5px;
    background-color: #009879;
    margin-bottom: 20px;
}
.styled-table {
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 0.9em;
    font-family: sans-serif;
    min-width: 400px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
}
.styled-table thead tr {
    background-color: #009879;
    color: #ffffff;
    text-align: left;
}
.styled-table th,
.styled-table td {
    padding: 12px 15px;
}
.styled-table tbody tr {
    border-bottom: 1px solid #dddddd;
}
.styled-table tbody tr:nth-of-type(even) {
    background-color: #f3f3f3;
}
.styled-table tbody tr:last-of-type {
    border-bottom: 2px solid #009879;
}
</style>
"""

# Combine CSS and HTML with a banner
html_output = f"""
<html>
<head>{css}</head>
<body>
<div class="banner">Your Organization Name</div>
<div class="thin-bar"></div>
{html_output}
</body>
</html>
"""

# Save the HTML output to a file
with open('output.html', 'w') as file:
    file.write(html_output)

print("CSV file and HTML table with CSS styling have been generated and saved as 'final_results.csv' and 'output.html'.")

#Method 2

import pyodbc
import pandas as pd
import datetime
import csv
import os

def query_sql_server(server, database, username, password, query):
    """
    Executes a SQL query against a specified SQL Server instance.

    Args:
        server: The SQL Server server name.
        database: The database name.
        username: The username for authentication.
        password: The password for authentication.
        query: The SQL query to execute.

    Returns:
        A pandas DataFrame containing the query results.
    """

    conn_str = (
        r"DRIVER={ODBC Driver 17 for SQL Server};"
        f"SERVER={server};"
        f"DATABASE={database};"
        f"UID={username};"
        f"PWD={password}"
    )

    try:
        conn = pyodbc.connect(conn_str)
        df = pd.read_sql_query(query, conn)
        conn.close()
        return df
    except pyodbc.Error as e:
        print(f"Error connecting to SQL Server: {e}")
        return None

def generate_date_range(start_date, end_date):
    """
    Generates a list of dates within a specified range.

    Args:
        start_date: The start date (inclusive).
        end_date: The end date (inclusive).

    Returns:
        A list of dates.
    """

    delta = end_date - start_date + datetime.timedelta(days=1)
    return [start_date + datetime.timedelta(days=i) for i in range(delta.days)]

def main():
    # Replace with your SQL Server credentials and database name
    server = "your_server_name"
    database = "your_database_name"
    username = "your_username"
    password = "your_password"

    # Replace with the path to your CSV file containing table names
    table_file = "table_names.csv"

    # Specify the start and end dates for the query
    start_date = datetime.date(2024, 1, 1)  # Replace with your desired start date
    end_date = datetime.date(2024, 12, 31)  # Replace with your desired end date

    # Read table names from the CSV file
    with open(table_file, 'r') as f:
        table_names = [row.strip() for row in f]

    # Create a list to store the query results
    results = []

    for table_name in table_names:
        query = f"""
            SELECT CAST(date_column AS DATE) AS date, COUNT(*) AS row_count
            FROM {table_name}
            WHERE date_column >= '{start_date}' AND date_column <= '{end_date}'
            GROUP BY CAST(date_column AS DATE)
        """

        # Replace 'date_column' with the actual column name in your table
        df = query_sql_server(server, database, username, password, query)

        # Create a DataFrame with all dates and fill missing values with 0
        date_range = generate_date_range(start_date, end_date)
        df_all_dates = pd.DataFrame({'date': date_range})
        df = df_all_dates.merge(df, on='date', how='left').fillna(0)

        # Add table name to the results
        df['table_name'] = table_name
        results.append(df)

    # Concatenate results from all tables
    final_df = pd.concat(results, ignore_index=True)

    # Save results to CSV
    final_df.to_csv('table_counts.csv', index=False)

    # Save results to HTML with CSS styling
    html_content = final_df.to_html(index=False, classes=['table', 'table-striped', 'table-bordered'])
    with open('table_counts.html', 'w') as f:
        f.write(html_content)

if __name__ == '__main__':
    main()

#Method 3

import pandas as pd
import csv
from io import StringIO
import datetime

# Simulating CSV content (replace this with actual CSV file reading)
csv_content = """TableName
Table1
Table2
Table3
"""
csv_file = StringIO(csv_content)

# Load table names from the CSV
table_names_df = pd.read_csv(csv_file)
table_names = table_names_df['TableName'].tolist()

# Specify the date range
start_date = datetime.date(2024, 1, 1)
end_date = datetime.date(2024, 12, 31)

# Generate all dates in the range
date_range = pd.date_range(start=start_date, end=end_date)

# Simulate row counts for each table by date
rows_by_date = {}
for table in table_names:
    for date in date_range:
        rows_count = abs(hash(table + str(date))) % 100  # Simulating a count
        rows_by_date.setdefault(table, {})[date.strftime('%Y-%m-%d')] = rows_count

# Create a DataFrame with all combinations of tables and dates
result_df = pd.DataFrame([(table, date, rows_by_date[table].get(date.strftime('%Y-%m-%d'), 0))
                          for table in table_names
                          for date in date_range],
                         columns=['TableName', 'Date', 'RowCount'])

# Export to CSV
result_df.to_csv('results.csv', index=False)

# Generate HTML table with CSS styling
html_table = """
<html>
<head>
<style>
    table {
        border-collapse: collapse;
        width: 100%;
        font-family: Arial, sans-serif;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    th {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    tr:hover {
        background-color: #f5f5f5;
    }
</style>
</head>
<body>
"""

html_table += result_df.to_html(index=False)
html_table += "</body></html>"

# Save HTML table to file
with open('results.html', 'w') as f:
    f.write(html_table)

print("CSV and HTML files have been generated.")

